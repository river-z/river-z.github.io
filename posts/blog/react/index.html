<!doctype html>
<html lang="zh">
  <head>
    <title>react相关 // Welcome to river&#39;s hugo site</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.105.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="react相关"/>
<meta name="twitter:description" content="hooks useState 可以更细粒度地拆分state，讲相关状态都放在一个对象中管理 useEffect return 一个函数，内部对标组件销毁前的时机，对标componentWillUnmount 内部逻辑对标componentDidMount &amp; componentDidUpdate ,传入的数组参数，发生改变时，重新渲染 useMemo 缓存一个变量 memo 缓存一个组件，使用场景：父组件更新state，但子组件不依赖于这些props更新的时候 memo检查props的变更时采用的是标准的js相等判断逻辑：对于基本数据类型执行值相等判断，对于引用数据类型执行引用相等判断。所以当组件props里的值为引用类型时，我们知道父组件的每一次render都会传递新的引用对象，memo进行相等判断时走引用相等逻辑判断，从而每次都会得到false的判断结果，也就不会阻止render过程，造成重复的渲染计算。所以一般可以useMemo&amp;useCallback搭配使用 单纯使用memo只是让组件拥有了 memoized 能力，而真正发挥出组件的 memoized 能力往往需要搭配useCallback 和 useMemo使用。 useCallback 缓存一个回调函数，使用场景：父组件更新state也会引发props传递的函数更新，相当于缓存了一个相同的引用 useContext 子孙组件或更深层次的组件数据共享 外部使用React.createContext 建立一个共享的数据对象，并用该对象的Provider方法包裹住组件（顶层声明Provider组件），value给值，子组件通过useContext(context对象名)/context.Consumer(内部需要用{}包裹一个cb)来消费。 useRef 首先需要明白useMemo和useCallback内置于React的初衷：
保证引用相等 避免昂贵的计算
注意点 涉及到性能优化的hooks内部都有一定的计算开销，不是任何时间都适用的，不要盲目使用，如果依赖的值只是一些简单的基本数据类型值，则不是那么必要 性能优化不是免费的。 它们总是带来成本，并且优化带来的好处并不总是能抵消成本。 react 源码18.6.0 createRoot.render 替代 ReactDom.render (文档参考)[https://www.51cto.com/article/706749.html]
运行npm run eject 之后报错，可以尝试更改启动命令 &ldquo;scripts&rdquo;: { &ldquo;start&rdquo;: &ldquo;node scripts/start.js&rdquo;, &ldquo;build&rdquo;: &ldquo;node scripts/build.js&rdquo;, &ldquo;test&rdquo;: &ldquo;node scriprs/test.js&rdquo; &hellip; }
批处理 setState 在18之前在异步回调/promise/定时器等里执行的时候会多次render，18&#43;合并了多次执行，可以通过ReactDOM.flushSync函数来手动进行强制同步执行（需要同步执行的函数放在这个函数内） 使用flushSync函数进行同步更新后，如果想要获取最新的state，需要在函数体外获取 Concurrent Mode (并发模式) CM 本身并不是一个功能，而是一个底层设计，它使 React 能够同时准备多个版本的 UI。 startTransition 默认情况下都是紧急的更新，但是我们可以通过这个api来指定哪些更新是非紧急的。 紧急更新(Urgent updates)：比如打字、点击、拖动等，需要立即响应的行为，如果不立即响应会给人很卡，或者出问题了的感觉。 过渡更新(Transition updates)：将 UI 从一个视图过渡到另一个视图。不需要即时响应，有些延迟是可以接受的。 流式 SSR 可以理解为，服务端返回页面渲染内容可以独立返回，而在之前如果包含了比较耗时的渲染，要等执行完毕之后一起返回（也就是所谓的串行执行，如果其中有一步比较慢，都会影响整体的渲染速度）。 "/>

    <meta property="og:title" content="react相关" />
<meta property="og:description" content="hooks useState 可以更细粒度地拆分state，讲相关状态都放在一个对象中管理 useEffect return 一个函数，内部对标组件销毁前的时机，对标componentWillUnmount 内部逻辑对标componentDidMount &amp; componentDidUpdate ,传入的数组参数，发生改变时，重新渲染 useMemo 缓存一个变量 memo 缓存一个组件，使用场景：父组件更新state，但子组件不依赖于这些props更新的时候 memo检查props的变更时采用的是标准的js相等判断逻辑：对于基本数据类型执行值相等判断，对于引用数据类型执行引用相等判断。所以当组件props里的值为引用类型时，我们知道父组件的每一次render都会传递新的引用对象，memo进行相等判断时走引用相等逻辑判断，从而每次都会得到false的判断结果，也就不会阻止render过程，造成重复的渲染计算。所以一般可以useMemo&amp;useCallback搭配使用 单纯使用memo只是让组件拥有了 memoized 能力，而真正发挥出组件的 memoized 能力往往需要搭配useCallback 和 useMemo使用。 useCallback 缓存一个回调函数，使用场景：父组件更新state也会引发props传递的函数更新，相当于缓存了一个相同的引用 useContext 子孙组件或更深层次的组件数据共享 外部使用React.createContext 建立一个共享的数据对象，并用该对象的Provider方法包裹住组件（顶层声明Provider组件），value给值，子组件通过useContext(context对象名)/context.Consumer(内部需要用{}包裹一个cb)来消费。 useRef 首先需要明白useMemo和useCallback内置于React的初衷：
保证引用相等 避免昂贵的计算
注意点 涉及到性能优化的hooks内部都有一定的计算开销，不是任何时间都适用的，不要盲目使用，如果依赖的值只是一些简单的基本数据类型值，则不是那么必要 性能优化不是免费的。 它们总是带来成本，并且优化带来的好处并不总是能抵消成本。 react 源码18.6.0 createRoot.render 替代 ReactDom.render (文档参考)[https://www.51cto.com/article/706749.html]
运行npm run eject 之后报错，可以尝试更改启动命令 &ldquo;scripts&rdquo;: { &ldquo;start&rdquo;: &ldquo;node scripts/start.js&rdquo;, &ldquo;build&rdquo;: &ldquo;node scripts/build.js&rdquo;, &ldquo;test&rdquo;: &ldquo;node scriprs/test.js&rdquo; &hellip; }
批处理 setState 在18之前在异步回调/promise/定时器等里执行的时候会多次render，18&#43;合并了多次执行，可以通过ReactDOM.flushSync函数来手动进行强制同步执行（需要同步执行的函数放在这个函数内） 使用flushSync函数进行同步更新后，如果想要获取最新的state，需要在函数体外获取 Concurrent Mode (并发模式) CM 本身并不是一个功能，而是一个底层设计，它使 React 能够同时准备多个版本的 UI。 startTransition 默认情况下都是紧急的更新，但是我们可以通过这个api来指定哪些更新是非紧急的。 紧急更新(Urgent updates)：比如打字、点击、拖动等，需要立即响应的行为，如果不立即响应会给人很卡，或者出问题了的感觉。 过渡更新(Transition updates)：将 UI 从一个视图过渡到另一个视图。不需要即时响应，有些延迟是可以接受的。 流式 SSR 可以理解为，服务端返回页面渲染内容可以独立返回，而在之前如果包含了比较耗时的渲染，要等执行完毕之后一起返回（也就是所谓的串行执行，如果其中有一步比较慢，都会影响整体的渲染速度）。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://river-z.github.io/posts/blog/react/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-22T15:22:37+08:00" />
<meta property="article:modified_time" content="2023-03-22T15:22:37+08:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://river-z.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <span class="app-header-title">Welcome to river&#39;s hugo site</span>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">react相关</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 22, 2023
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="hooks">hooks</h2>
<h3 id="usestate">useState</h3>
<ul>
<li>可以更细粒度地拆分state，讲相关状态都放在一个对象中管理</li>
</ul>
<h3 id="useeffect">useEffect</h3>
<ul>
<li>return 一个函数，内部对标组件销毁前的时机，对标componentWillUnmount</li>
<li>内部逻辑对标componentDidMount &amp; componentDidUpdate ,传入的数组参数，发生改变时，重新渲染</li>
</ul>
<h3 id="usememo">useMemo</h3>
<ul>
<li>缓存一个变量</li>
</ul>
<h3 id="memo">memo</h3>
<ul>
<li>缓存一个组件，使用场景：父组件更新state，但子组件不依赖于这些props更新的时候</li>
<li>memo检查props的变更时采用的是标准的js相等判断逻辑：对于基本数据类型执行值相等判断，对于引用数据类型执行引用相等判断。所以当组件props里的值为引用类型时，我们知道父组件的每一次render都会传递新的引用对象，memo进行相等判断时走引用相等逻辑判断，从而每次都会得到false的判断结果，也就不会阻止render过程，造成重复的渲染计算。所以一般可以useMemo&amp;useCallback搭配使用</li>
<li>单纯使用memo只是让组件拥有了 memoized 能力，而真正发挥出组件的 memoized 能力往往需要搭配useCallback 和 useMemo使用。</li>
</ul>
<h3 id="usecallback">useCallback</h3>
<ul>
<li>缓存一个回调函数，使用场景：父组件更新state也会引发props传递的函数更新，相当于缓存了一个相同的引用</li>
</ul>
<h3 id="usecontext">useContext</h3>
<ul>
<li>子孙组件或更深层次的组件数据共享</li>
<li>外部使用React.createContext 建立一个共享的数据对象，并用该对象的Provider方法包裹住组件（顶层声明Provider组件），value给值，子组件通过useContext(context对象名)/context.Consumer(内部需要用{}包裹一个cb)来消费。</li>
</ul>
<h3 id="useref">useRef</h3>
<p>首先需要明白useMemo和useCallback内置于React的初衷：</p>
<p>保证引用相等
避免昂贵的计算</p>
<h3 id="注意点">注意点</h3>
<ul>
<li>涉及到性能优化的hooks内部都有一定的计算开销，不是任何时间都适用的，不要盲目使用，如果依赖的值只是一些简单的基本数据类型值，则不是那么必要</li>
<li>性能优化不是免费的。 它们总是带来成本，并且优化带来的好处并不总是能抵消成本。</li>
</ul>
<h2 id="react-源码1860">react 源码18.6.0</h2>
<h3 id="createrootrender-替代-reactdomrender">createRoot.render 替代 ReactDom.render</h3>
<p>(文档参考)[https://www.51cto.com/article/706749.html]</p>
<h3 id="运行npm-run-eject-之后报错可以尝试更改启动命令">运行npm run eject 之后报错，可以尝试更改启动命令</h3>
<p>&ldquo;scripts&rdquo;: {
&ldquo;start&rdquo;: &ldquo;node scripts/start.js&rdquo;,
&ldquo;build&rdquo;: &ldquo;node scripts/build.js&rdquo;,
&ldquo;test&rdquo;: &ldquo;node scriprs/test.js&rdquo;
&hellip;
}</p>
<h3 id="批处理">批处理</h3>
<ul>
<li>setState 在18之前在异步回调/promise/定时器等里执行的时候会多次render，18+合并了多次执行，可以通过ReactDOM.flushSync函数来手动进行强制同步执行（需要同步执行的函数放在这个函数内）</li>
<li>使用flushSync函数进行同步更新后，如果想要获取最新的state，需要在函数体外获取</li>
</ul>
<h3 id="concurrent-mode-并发模式">Concurrent Mode (并发模式)</h3>
<ul>
<li>CM 本身并不是一个功能，而是一个底层设计，它使 React 能够同时准备多个版本的 UI。</li>
</ul>
<h3 id="starttransition">startTransition</h3>
<ul>
<li>默认情况下都是紧急的更新，但是我们可以通过这个api来指定哪些更新是非紧急的。</li>
</ul>
<ul>
<li>紧急更新(Urgent updates)：比如打字、点击、拖动等，需要立即响应的行为，如果不立即响应会给人很卡，或者出问题了的感觉。</li>
<li>过渡更新(Transition updates)：将 UI 从一个视图过渡到另一个视图。不需要即时响应，有些延迟是可以接受的。</li>
</ul>
<h3 id="流式-ssr">流式 SSR</h3>
<ul>
<li>可以理解为，服务端返回页面渲染内容可以独立返回，而在之前如果包含了比较耗时的渲染，要等执行完毕之后一起返回（也就是所谓的串行执行，如果其中有一步比较慢，都会影响整体的渲染速度）。</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
